<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Cyber Cafe Startpage</title>
    <meta name="theme-color" content="#111827" />
    <link rel="manifest" href="manifest.json" />
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 64 64'%3E%3Ccircle cx='32' cy='32' r='30' fill='%23111827'/%3E%3Cpath d='M20 26h24v18a10 10 0 01-10 10H30a10 10 0 01-10-10V26z' fill='%23ffffff' opacity='0.9'/%3E%3Cpath d='M24 20c0-3 2-6 8-6s8 3 8 6c0 2-1 3-2 4-1 1-2 2-2 4h-8c0-2-1-3-2-4-1-1-2-2-2-4z' fill='%23a78bfa'/%3E%3C/svg%3E" />
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <!-- React Libraries -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <!-- Babel Compiler -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
    html, body { height: 100%; overflow: hidden; overscroll-behavior: none; }
    html { overflow-x: clip; }
    *, *::before, *::after { box-sizing: border-box; }
      body {
        font-family: 'Inter', sans-serif;
        background-color: #111827; /* bg-gray-900 */
        color: white;
        min-height: 100vh;
                margin: 0;
      }
    #root, #main-content { width: 100vw; height: 100vh; overflow: hidden; }
            @media (prefers-reduced-motion: reduce) {
                * { transition: none !important; animation: none !important; }
            }
      .acrylic-box {
        background-color: rgba(0, 0, 0, 0.25);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 0.75rem;
      }
      .filter-btn {
        flex-grow: 1;
        padding: 0.5rem 0;
        border: 1px solid #4b5563;
        background-color: rgba(75, 85, 99, 0.5);
        color: #d1d5db;
        font-weight: 500;
        transition: all 0.2s;
        cursor: pointer;
      }
      .filter-btn:not(:first-child) {
        border-left-width: 0;
      }
      .filter-btn.general-active, .filter-btn.anime-active, .filter-btn.people-active {
        background-color: #4338ca;
        border-color: #4f46e5;
        color: white;
      }
      .filter-btn.sfw-active { background-color: #166534; border-color: #15803d; color: white; }
      .filter-btn.sketchy-active { background-color: #854d0e; border-color: #a16207; color: white; }
      .filter-btn.nsfw-active { background-color: #991b1b; border-color: #b91c1c; color: white; }
      .form-checkbox {
        appearance: none;
        -webkit-appearance: none;
        height: 1.25rem;
        width: 1.25rem;
        border: 1px solid #4b5563;
        border-radius: 0.25rem;
        background-color: rgba(31, 41, 55, 0.5);
        cursor: pointer;
        display: inline-block;
        position: relative;
      }
      .form-checkbox:checked {
        background-color: #4f46e5;
        border-color: #4f46e5;
      }
      .form-checkbox:checked::after {
        content: 'âœ”';
        font-size: 0.8rem;
        color: white;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
      }
      #background-container {
        transition: background-image 0.5s ease-in-out;
      }
    </style>
  </head>
  <body>
    <div id="root"></div>

        <script type="text/babel">
            const { useState, useEffect, useCallback, useMemo, useRef } = React;

      // --- Helper Components ---
      const Icon = ({ path, className = "h-6 w-6" }) => (
          <svg xmlns="http://www.w3.org/2000/svg" className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d={path} />
          </svg>
      );
    const Spinner = () => <div className="animate-spin rounded-full h-6 w-6 border-b-2 border-white"></div>;

      // --- Main App Components ---
      const Clock = ({ dateMode }) => {
          const [time, setTime] = useState(new Date());
          useEffect(() => {
              const timerId = setInterval(() => setTime(new Date()), 1000);
              return () => clearInterval(timerId);
          }, []);
          const formattedDate = useMemo(() => {
              const now = new Date();
              switch (dateMode) {
                  case 'full': return now.toLocaleDateString([], { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });
                  case 'day': return now.toLocaleDateString([], { weekday: 'long' });
                  case 'none': return '';
                  default: return '';
              }
          }, [dateMode, time]);
          return (
              <div className="text-center mb-8 p-4 acrylic-box">
                  <h1 id="time" className="text-6xl md:text-8xl font-bold tracking-tight">{time.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: true })}</h1>
                  <p id="date" className="text-lg md:text-2xl opacity-80">{formattedDate}</p>
              </div>
          );
      };

      const ShortcutsGrid = ({ shortcuts }) => (
          <div id="shortcuts-grid-container" className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4 p-4 acrylic-box w-full max-w-4xl">
              {shortcuts.map((shortcut) => (
                  <a key={shortcut.id || shortcut.url} href={shortcut.url} target="_blank" rel="noopener noreferrer" className="h-16 bg-black/20 px-4 rounded-lg text-center hover:bg-black/40 transition-colors flex items-center justify-center min-w-0">
                      <span className="font-medium truncate">{shortcut.name}</span>
                  </a>
              ))}
          </div>
      );

    const SettingsPanel = ({ config, setConfig, isOpen, onClose, showNotification, fetchWallhavenWallpaper }) => {
          const [activeTab, setActiveTab] = useState('display');
          const [localConfig, setLocalConfig] = useState(config);
          const [dragIndex, setDragIndex] = useState(null);
          const [dragOverIndex, setDragOverIndex] = useState(null);
          const [dragOverPos, setDragOverPos] = useState(null); // 'before' | 'after'
          useEffect(() => { if (isOpen) { setLocalConfig(config); } }, [config, isOpen]);
          // Close on Escape
          useEffect(() => {
              if (!isOpen) return;
              const onKey = (e) => { if (e.key === 'Escape') onClose(); };
              window.addEventListener('keydown', onKey);
              return () => window.removeEventListener('keydown', onKey);
          }, [isOpen, onClose]);
          
          const handleSave = () => {
              const finalConfig = { ...localConfig };
              const oldConfig = { ...config };
              
              // Sanitize bgUrl and decide mode
              const rawUrl = (localConfig.bgUrl || '').trim();
              if (rawUrl) {
                  try {
                      const u = new URL(rawUrl, window.location.href);
                      if (u.protocol === 'http:' || u.protocol === 'https:') {
                          finalConfig.bgUrl = u.href;
                          finalConfig.bgMode = 'url';
                      } else {
                          showNotification('Unsupported image URL protocol. Using Wallhaven.', true);
                          finalConfig.bgUrl = '';
                          finalConfig.bgMode = 'wallhaven';
                      }
                  } catch {
                      showNotification('Invalid image URL. Using Wallhaven.', true);
                      finalConfig.bgUrl = '';
                      finalConfig.bgMode = 'wallhaven';
                  }
              } else {
                  finalConfig.bgMode = 'wallhaven';
              }
              
              setConfig(finalConfig);
              onClose();
              showNotification("Settings saved.", false);
              // Only fetch if Wallhaven-relevant settings changed or we switched into Wallhaven mode
              const wallhavenFields = ['wallhavenTags','wallhavenSorting','wallhavenCategories','wallhavenPurity','wallhavenApiKey','wallhavenMatchResolution'];
              const switchedToWallhaven = oldConfig.bgMode !== 'wallhaven' && finalConfig.bgMode === 'wallhaven';
              const wallhavenChanged = wallhavenFields.some(k => JSON.stringify(oldConfig[k]) !== JSON.stringify(finalConfig[k]));
              if (finalConfig.bgMode === 'wallhaven' && (switchedToWallhaven || wallhavenChanged)) {
                  fetchWallhavenWallpaper(finalConfig);
              }
          };

          const handleConfigChange = (field, value) => setLocalConfig(prev => ({ ...prev, [field]: value }));
          const updateShortcutsLive = (nextShortcuts) => {
              setLocalConfig(prev => ({ ...prev, shortcuts: nextShortcuts }));
              setConfig(prev => ({ ...prev, shortcuts: nextShortcuts }));
          };
          const handleDateModeChange = (e) => {
              const newDateMode = e.target.value;
              setLocalConfig(prev => ({ ...prev, dateMode: newDateMode }));
              setConfig(prev => ({ ...prev, dateMode: newDateMode }));
          };
          const handleCategoryChange = (index) => {
              const newCategories = [...localConfig.wallhavenCategories];
              newCategories[index] = !newCategories[index];
              handleConfigChange('wallhavenCategories', newCategories);
          };
          const handlePurityChange = (index) => {
              const newPurity = [...localConfig.wallhavenPurity];
              newPurity[index] = !newPurity[index];
              handleConfigChange('wallhavenPurity', newPurity);
          };
          const isWallhavenDisabled = localConfig.bgUrl.trim() !== '';
          const isNsfwDisabled = isWallhavenDisabled || !localConfig.wallhavenApiKey;
          return (
              <div role="dialog" aria-modal="true" aria-label="Settings" className={`fixed top-0 right-0 h-full w-full max-w-md bg-gray-800/70 backdrop-blur-md shadow-2xl flex flex-col transform transition-transform z-30 ${isOpen ? 'translate-x-0' : 'translate-x-full'}`}>
                  <div className="flex justify-between items-center p-6 border-b border-gray-700 flex-shrink-0">
                      <h2 className="text-2xl font-bold">Settings</h2>
                      <button onClick={onClose} className="p-2 rounded-full hover:bg-white/10 transition-colors"><Icon path="M6 18L18 6M6 6l12 12" /></button>
                  </div>
                  <div className="flex border-b border-gray-600 flex-shrink-0">
                      <button onClick={() => setActiveTab('display')} className={`py-2 px-4 w-1/2 ${activeTab === 'display' ? 'border-b-2 border-indigo-500 text-white' : 'text-gray-400'}`}>Display & Wallpaper</button>
                      <button onClick={() => setActiveTab('shortcuts')} className={`py-2 px-4 w-1/2 ${activeTab === 'shortcuts' ? 'border-b-2 border-indigo-500 text-white' : 'text-gray-400'}`}>Shortcuts</button>
                  </div>
                  <div className="flex-grow p-6 space-y-6 overflow-y-auto">
                      {activeTab === 'display' && (
                          <div className="space-y-6">
                              <section>
                                  <h3 className="text-lg font-semibold mb-4 text-indigo-400">General</h3>
                                  <div>
                                      <label htmlFor="date-display-mode" className="block text-sm font-medium mb-1">Date Format</label>
                                      <select value={localConfig.dateMode} onChange={handleDateModeChange} className="w-full bg-gray-900/50 border border-gray-700 rounded-md px-3 py-2 text-white focus:outline-none focus:ring-2 focus:ring-indigo-500">
                                          <option value="full">Full Date</option>
                                          <option value="day">Day of the Week Only</option>
                                          <option value="none">Hide Date</option>
                                      </select>
                                  </div>
                              </section>
                              <hr className="border-gray-700"/>
                              <section>
                                  <h3 className="text-lg font-semibold mb-4 text-indigo-400">Wallpaper</h3>
                                  <div className="space-y-2">
                                      <label htmlFor="wallpaper-url" className="block text-sm font-medium">Custom URL</label>
                                      <input id="wallpaper-url" type="text" value={localConfig.bgUrl} onChange={(e) => handleConfigChange('bgUrl', e.target.value)} placeholder="Enter an image URL to override Wallhaven" className="w-full bg-gray-900/50 border border-gray-700 rounded-md px-3 py-2 text-white focus:outline-none focus:ring-2 focus:ring-blue-500" />
                                  </div>
                                  <div className={`space-y-4 mt-4 transition-opacity ${isWallhavenDisabled ? 'opacity-50' : ''}`}>
                                      <p className="text-sm opacity-70">Or, configure Wallhaven (active when Custom URL is empty).</p>
                                      <div>
                                          <label className="block text-sm font-medium mb-2">Filters</label>
                                          <div className="grid grid-cols-3 gap-1">
                                              <button onClick={() => handleCategoryChange(0)} disabled={isWallhavenDisabled} className={`filter-btn rounded-l-md ${localConfig.wallhavenCategories[0] ? 'general-active' : ''}`}>General</button>
                                              <button onClick={() => handleCategoryChange(1)} disabled={isWallhavenDisabled} className={`filter-btn ${localConfig.wallhavenCategories[1] ? 'anime-active' : ''}`}>Anime</button>
                                              <button onClick={() => handleCategoryChange(2)} disabled={isWallhavenDisabled} className={`filter-btn rounded-r-md ${localConfig.wallhavenCategories[2] ? 'people-active' : ''}`}>People</button>
                                              <button onClick={() => handlePurityChange(0)} disabled={isWallhavenDisabled} className={`filter-btn rounded-l-md ${localConfig.wallhavenPurity[0] ? 'sfw-active' : ''}`}>SFW</button>
                                              <button onClick={() => handlePurityChange(1)} disabled={isWallhavenDisabled} className={`filter-btn ${localConfig.wallhavenPurity[1] ? 'sketchy-active' : ''}`}>Sketchy</button>
                                              <button onClick={() => handlePurityChange(2)} disabled={isNsfwDisabled} className={`filter-btn rounded-r-md ${localConfig.wallhavenPurity[2] ? 'nsfw-active' : ''} ${isNsfwDisabled ? 'opacity-50 cursor-not-allowed' : ''}`}>NSFW</button>
                                          </div>
                                      </div>
                                      <div>
                                          <label htmlFor="wallhaven-tags" className="block text-sm font-medium mb-1">Tags</label>
                                          <input id="wallhaven-tags" type="text" value={localConfig.wallhavenTags} onChange={e => handleConfigChange('wallhavenTags', e.target.value)} placeholder="digital art, landscape" disabled={isWallhavenDisabled} className="w-full bg-gray-900/50 border border-gray-700 rounded-md px-3 py-2 text-white focus:outline-none focus:ring-2 focus:ring-indigo-500 disabled:cursor-not-allowed" />
                                      </div>
                                      <div>
                                          <label htmlFor="wallhaven-sorting" className="block text-sm font-medium mb-1">Sort By</label>
                                          <select id="wallhaven-sorting" value={localConfig.wallhavenSorting} onChange={e => handleConfigChange('wallhavenSorting', e.target.value)} disabled={isWallhavenDisabled} className="w-full bg-gray-900/50 border border-gray-700 rounded-md px-3 py-2 text-white focus:outline-none focus:ring-2 focus:ring-indigo-500 disabled:cursor-not-allowed">
                                              <option value="random">Random</option>
                                              <option value="toplist">Toplist</option>
                                              <option value="hot">Hot</option>
                                              <option value="date_added">Newest</option>
                                              <option value="views">Views</option>
                                              <option value="favorites">Favorites</option>
                                          </select>
                                      </div>
                                      <div>
                                          <label className={`flex items-center space-x-2 ${isWallhavenDisabled ? '' : 'cursor-pointer'}`}>
                                              <input type="checkbox" checked={localConfig.wallhavenMatchResolution} onChange={e => handleConfigChange('wallhavenMatchResolution', e.target.checked)} disabled={isWallhavenDisabled} className="form-checkbox" />
                                              <span>Match Screen Resolution</span>
                                          </label>
                                      </div>
                                      <div>
                                          <label htmlFor="wallhaven-apikey" className="block text-sm font-medium mb-1">API Key</label>
                                          <input id="wallhaven-apikey" type="password" value={localConfig.wallhavenApiKey} onChange={e => handleConfigChange('wallhavenApiKey', e.target.value)} disabled={isWallhavenDisabled} placeholder="Optional, for full access" className="w-full bg-gray-900/50 border border-gray-700 rounded-md px-3 py-2 text-white focus:outline-none focus:ring-2 focus:ring-indigo-500 disabled:cursor-not-allowed" />
                                          <p className="text-xs text-gray-400 mt-1">An API key is required for NSFW content. Get yours from your <a href="https://wallhaven.cc/settings/account" target="_blank" rel="noopener noreferrer" className="text-indigo-400 hover:underline">account settings</a>.</p>
                                      </div>
                                      <div>
                                          <label htmlFor="image-proxy-mode" className="block text-sm font-medium mb-1">Image Proxy</label>
                                          <select id="image-proxy-mode" value={localConfig.imageProxyMode || 'auto'} onChange={e => handleConfigChange('imageProxyMode', e.target.value)} className="w-full bg-gray-900/50 border border-gray-700 rounded-md px-3 py-2 text-white focus:outline-none focus:ring-2 focus:ring-indigo-500">
                                              <option value="auto">Auto (try direct, then proxy)</option>
                                              <option value="always">Always use proxy</option>
                                              <option value="off">Off (direct only)</option>
                                          </select>
                                          <p className="text-xs text-gray-400 mt-1">Using a proxy helps avoid hotlinking and CORS errors on some images.</p>
                                      </div>
                                  </div>
                              </section>
                          </div>
                      )}
                      {activeTab === 'shortcuts' && (
                           <section>
                              <h3 className="text-lg font-semibold mb-4 text-indigo-400">Shortcuts</h3>
                              <div className="space-y-3">
                                  {localConfig.shortcuts.map((shortcut, index) => (
                                      <div key={shortcut.id || index}
                                           data-index={index}
                                           className="relative flex gap-2 items-center"
                                           onDragOver={e => {
                                               e.preventDefault();
                                               const rect = e.currentTarget.getBoundingClientRect();
                                               const pos = (e.clientY - rect.top) < rect.height / 2 ? 'before' : 'after';
                                               setDragOverIndex(index);
                                               setDragOverPos(pos);
                                           }}
                                           onDragLeave={() => { setDragOverIndex(null); setDragOverPos(null); }}
                                           onDrop={e => {
                                               e.preventDefault();
                                               const fromIdx = dragIndex;
                                               const baseIdx = index;
                                               const insertPos = dragOverPos || 'after';
                                               setDragOverIndex(null); setDragOverPos(null);
                                               if (fromIdx == null) return;
                                               let toIdx = baseIdx + (insertPos === 'after' ? 1 : 0);
                                               const list = [...localConfig.shortcuts];
                                               const [moved] = list.splice(fromIdx, 1);
                                               if (fromIdx < toIdx) toIdx -= 1; // account for removal shift
                                               list.splice(toIdx, 0, moved);
                                               updateShortcutsLive(list);
                                           }}>
                                          {/* insertion indicator */}
                                          {dragOverIndex === index && dragOverPos === 'before' && <div className="absolute -top-1 left-0 right-0 h-0.5 bg-indigo-500 rounded"></div>}
                                          {dragOverIndex === index && dragOverPos === 'after' && <div className="absolute -bottom-1 left-0 right-0 h-0.5 bg-indigo-500 rounded"></div>}
                                          <button title="Drag to reorder"
                                                  draggable
                                                  onDragStart={() => setDragIndex(index)}
                                                  onDragEnd={() => { setDragIndex(null); setDragOverIndex(null); setDragOverPos(null); }}
                                                  className="p-2 rounded-md hover:bg-white/10 cursor-move">
                                              <Icon path="M4 8h16M4 12h16M4 16h16" className="h-5 w-5" />
                                          </button>
                                          <input type="text" value={shortcut.name} onChange={e => {
                                              const list = [...localConfig.shortcuts];
                                              list[index] = { ...list[index], name: e.target.value };
                                              updateShortcutsLive(list);
                                          }} className="w-1/3 bg-gray-900/50 border border-gray-700 rounded-md px-3 py-2 text-white focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="Name" />
                                          <input type="text" value={shortcut.url} onChange={e => {
                                              const list = [...localConfig.shortcuts];
                                              list[index] = { ...list[index], url: e.target.value };
                                              updateShortcutsLive(list);
                                          }} className="w-2/3 bg-gray-900/50 border border-gray-700 rounded-md px-3 py-2 text-white focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="URL" />
                                          <button onClick={() => {
                                              const list = localConfig.shortcuts.filter((s, i) => i !== index);
                                              updateShortcutsLive(list);
                                          }} className="text-red-500 hover:text-red-400 p-2 rounded-full hover:bg-white/10 transition-colors">
                                              <Icon path="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" className="h-5 w-5" />
                                          </button>
                                      </div>
                                  ))}
                              </div>
                              <button onClick={() => {
                                  const makeId = () => 's_' + Date.now().toString(36) + '_' + Math.random().toString(36).slice(2,8);
                                  const list = [...(localConfig.shortcuts || []) , { id: makeId(), name: 'New Link', url: 'https://' }];
                                  updateShortcutsLive(list);
                              }} className="mt-4 w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-md transition-colors">Add Shortcut</button>
                          </section>
                      )}
                  </div>
                  <div className="p-6 border-t border-gray-700 flex-shrink-0">
                      <button onClick={handleSave} className="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-md transition-colors">Save Changes</button>
                  </div>
              </div>
          );
      };

      function App() {
          const [config, setConfig] = useState(null);
          const [isSettingsOpen, setIsSettingsOpen] = useState(false);
          const [notification, setNotification] = useState({ show: false, message: '', isError: false });
          const [isRefreshing, setIsRefreshing] = useState(false);
          const notifTimeoutRef = useRef(null);
          const [nextWallpaper, setNextWallpaper] = useState(null); // { id, path, loaded }
          const contentRef = useRef(null);
          const [overlayPos, setOverlayPos] = useState(null); // { x, y } in px; null = centered
          const lastImageUrlRef = useRef(null);
          const [overlayPositions, setOverlayPositions] = useState({}); // key => {x,y}
          const manualOverrideRef = useRef(false);
          const isDraggingRef = useRef(false);
          const dragStartRef = useRef({ x: 0, y: 0 });
          const overlayStartRef = useRef({ x: 0, y: 0 });
          const overlaySizeRef = useRef({ w: 0, h: 0 });
          const overlayPosRef = useRef(null); // mirror of overlayPos for event handlers
          const analyzeRunIdRef = useRef(0); // increments to cancel in-flight analysis

          const getAtLeastResolution = () => `${window.screen.width}x${window.screen.height}`;
          const getWallpaperKey = useCallback(() => {
              if (!config) return null;
              if (config.bgMode === 'wallhaven' && config.wallhavenId) return `wh:${config.wallhavenId}`;
              if (config.bgMode === 'url' && config.bgUrl) return `url:${config.bgUrl}`;
              return null;
          }, [config]);

          const saveOverlayPosition = useCallback((key, pos) => {
              if (!key || !pos) return;
              setOverlayPositions(prev => {
                  const next = { ...prev, [key]: { x: Math.round(pos.x), y: Math.round(pos.y) } };
                  try { localStorage.setItem('overlayPositions', JSON.stringify(next)); } catch {}
                  return next;
              });
          }, []);

          // Load saved overlay positions
          useEffect(() => {
              try {
                  const raw = localStorage.getItem('overlayPositions');
                  if (raw) setOverlayPositions(JSON.parse(raw));
              } catch {}
          }, []);

          // Small helper: fetch with timeout
          const fetchWithTimeout = (url, { timeout = 8000 } = {}) => {
              const ctrl = new AbortController();
              const id = setTimeout(() => ctrl.abort('timeout'), timeout);
              return fetch(url, { signal: ctrl.signal }).finally(() => clearTimeout(id));
          };

          const preloadImage = (url) => new Promise((resolve, reject) => {
              const img = new Image();
              // Do not set crossOrigin here; we only need the browser cache and CSS bg to succeed
              img.onload = () => resolve(url);
              img.onerror = reject;
              img.src = url;
          });

          const loadImage = (url) => new Promise((resolve, reject) => {
              const img = new Image();
              try { img.crossOrigin = 'anonymous'; } catch {}
              img.onload = () => resolve(img);
              img.onerror = reject;
              img.src = url;
          });

          const analyzeAndPosition = async (imgUrl) => {
              const runId = ++analyzeRunIdRef.current;
              if (manualOverrideRef.current) return; // respect manual placement until wallpaper changes
              try {
                  const contentEl = contentRef.current;
                  if (!contentEl) return setOverlayPos(null);
                  // Measure overlay size
                  const rect = contentEl.getBoundingClientRect();
                  const vw = window.innerWidth || document.documentElement.clientWidth;
                  const vh = window.innerHeight || document.documentElement.clientHeight;
                  if (!rect.width || !rect.height || !vw || !vh) return setOverlayPos(null);

                  const img = await loadImage(imgUrl);
                  // Build a canvas that matches viewport aspect for consistent mapping
                  const cw = 160; // keep small for speed
                  const ch = Math.max(90, Math.round(cw * vh / Math.max(1, vw)));
                  const canvas = document.createElement('canvas');
                  canvas.width = cw; canvas.height = ch;
                  const ctx = canvas.getContext('2d');
                  ctx.drawImage(img, 0, 0, cw, ch);
                  const imageData = ctx.getImageData(0, 0, cw, ch);
                  const data = imageData.data;
                  // Luminance array
                  const lum = new Float32Array(cw * ch);
                  for (let y = 0, i = 0, p = 0; y < ch; y++) {
                      for (let x = 0; x < cw; x++, i++, p += 4) {
                          const r = data[p], g = data[p+1], b = data[p+2];
                          lum[i] = 0.299*r + 0.587*g + 0.114*b;
                      }
                  }
                  // Simple gradient energy: right and down diffs
                  const energy = new Float32Array(cw * ch);
                  let total = 0;
                  for (let y = 0; y < ch; y++) {
                      for (let x = 0; x < cw; x++) {
                          const i = y*cw + x;
                          const right = x+1 < cw ? lum[y*cw + (x+1)] : lum[i];
                          const down  = y+1 < ch ? lum[(y+1)*cw + x] : lum[i];
                          const e = Math.abs(lum[i] - right) + Math.abs(lum[i] - down);
                          energy[i] = e; total += e;
                      }
                  }
                  const avgEnergy = total / (cw * ch);
                  // Integral image for fast area sums
                  const integral = new Float32Array((cw+1) * (ch+1));
                  for (let y = 1; y <= ch; y++) {
                      let rowSum = 0;
                      for (let x = 1; x <= cw; x++) {
                          rowSum += energy[(y-1)*cw + (x-1)];
                          integral[y*(cw+1) + x] = integral[(y-1)*(cw+1) + x] + rowSum;
                      }
                  }
                  const targetW = Math.max(8, Math.round(rect.width / vw * cw));
                  const targetH = Math.max(8, Math.round(rect.height / vh * ch));
                  const marginX = Math.round(0.02 * cw); // ~2% canvas margin
                  const marginY = Math.round(0.02 * ch);
                  let best = { score: Number.POSITIVE_INFINITY, x: Math.round((cw-targetW)/2), y: Math.round((ch-targetH)/2) };
                  const cx = cw/2, cy = ch/2;
                  // Iterate candidate positions
                  for (let y = marginY; y <= ch - targetH - marginY; y++) {
                      for (let x = marginX; x <= cw - targetW - marginX; x++) {
                          const x2 = x + targetW, y2 = y + targetH;
                          const sum = integral[y2*(cw+1) + x2] - integral[y*(cw+1) + x2] - integral[y2*(cw+1) + x] + integral[y*(cw+1) + x];
                          // Prefer minimal energy; mild bias away from center only if energies are close
                          const centerDist = Math.hypot((x + targetW/2) - cx, (y + targetH/2) - cy) / Math.hypot(cx, cy);
                          const score = sum + centerDist * 0.02 * avgEnergy * targetW * targetH;
                          if (score < best.score) best = { score, x, y };
                      }
                  }
                  const windowEnergyPerPixel = best.score / (targetW * targetH);
                  // If no clearly low-energy region, fall back to center
                  if (windowEnergyPerPixel > avgEnergy * 0.95) {
                      if (runId !== analyzeRunIdRef.current || manualOverrideRef.current) return;
                      setOverlayPos(null);
                      overlayPosRef.current = null;
                      return;
                  }
                  const px = Math.round(best.x / cw * vw);
                  const py = Math.round(best.y / ch * vh);
                  const clampedX = Math.max(8, Math.min(px, vw - rect.width - 8));
                  const clampedY = Math.max(8, Math.min(py, vh - rect.height - 8));
                  if (runId !== analyzeRunIdRef.current || manualOverrideRef.current) return;
                  const pos = { x: clampedX, y: clampedY };
                  setOverlayPos(pos);
                  overlayPosRef.current = pos;
              } catch (err) {
                  // Likely CORS-tainted canvas or other issue; fall back to center
                  if (runId !== analyzeRunIdRef.current || manualOverrideRef.current) return;
                  setOverlayPos(null);
                  overlayPosRef.current = null;
              }
          };

          // Build candidate URLs for display, with proxy fallbacks
          const buildImageCandidates = (originalUrl, mode = 'auto') => {
              const candidates = [];
              const weserv = 'https://wsrv.nl/?url=' + encodeURIComponent(originalUrl);
              const corsproxy = 'https://corsproxy.io/?' + encodeURIComponent(originalUrl);
              const allorigins = 'https://api.allorigins.win/raw?url=' + encodeURIComponent(originalUrl);
              const addUnique = (u) => { if (!candidates.includes(u)) candidates.push(u); };
              const isAlways = mode === 'always';
              const isOff = mode === 'off';
              if (!isAlways) addUnique(originalUrl);
              if (!isOff) {
                  addUnique(weserv);
                  addUnique(corsproxy);
                  addUnique(allorigins);
              }
              if (isAlways) addUnique(originalUrl); // as last resort
              return candidates;
          };

          // Resolve a display URL by preloading sequentially through candidates
          const resolveDisplayUrl = async (originalUrl, mode = 'auto') => {
              const list = buildImageCandidates(originalUrl, mode);
              for (const url of list) {
                  try { await preloadImage(url); return url; } catch {}
              }
              throw new Error('All image candidates failed');
          };

          // Choose a CORS-friendly URL for analysis specifically
          const getAnalysisUrl = (originalUrl, chosenUrl) => {
              const isCorsFriendly = chosenUrl.startsWith('https://wsrv.nl/') || chosenUrl.startsWith('https://images.weserv.nl/') || chosenUrl.startsWith('https://corsproxy.io/') || chosenUrl.startsWith('https://api.allorigins.win/');
              if (isCorsFriendly) return chosenUrl;
              return 'https://wsrv.nl/?url=' + encodeURIComponent(originalUrl);
          };

          const fetchWallhavenWallpaper = useCallback(async (fetchConfig, prefetchOnly = false) => {
              setIsRefreshing(true);
              const proxies = ['https://corsproxy.io/?', 'https://api.allorigins.win/raw?url='];
              const { wallhavenTags, wallhavenSorting, wallhavenCategories, wallhavenPurity, wallhavenApiKey, wallhavenMatchResolution } = fetchConfig;

              const buildParams = (relax = false) => {
                  const params = new URLSearchParams();
                  const tags = (wallhavenTags || '').trim();
                  const cats = (wallhavenCategories || [true, true, true]).map(c => c ? '1' : '0').join('');
                  const purityFlags = [...(wallhavenPurity || [true, false, false])];
                  const purity = purityFlags.map(p => p ? '1' : '0').join('');

                  if (!relax && tags) params.append('q', tags);
                  params.append('sorting', wallhavenSorting || 'toplist');
                  params.append('categories', cats);
                  params.append('purity', purity);
                  if (!relax && wallhavenMatchResolution) {
                      params.append('atleast', getAtLeastResolution());
                  }
                  if ((wallhavenSorting || 'toplist') === 'random') {
                      const seed = new Date().toISOString().slice(0, 10); // daily seed
                      params.append('seed', seed);
                  }
                  if (wallhavenApiKey) params.append('apikey', wallhavenApiKey);
                  return params;
              };

              const tryFetch = async (params) => {
                  const apiUrl = `https://wallhaven.cc/api/v1/search?${params.toString()}`;
                  const attempts = proxies.map(p => (
                      fetchWithTimeout(p + encodeURIComponent(apiUrl), { timeout: 9000 })
                        .then(r => { if (!r.ok) throw new Error(`HTTP ${r.status}`); return r.json(); })
                  ));
                  let data;
                  if (Promise.any) {
                      data = await Promise.any(attempts);
                  } else {
                      data = await new Promise((resolve, reject) => {
                          let rejections = 0;
                          attempts.forEach(p => p.then(resolve).catch(() => { rejections++; if (rejections === attempts.length) reject(new Error('All proxies failed')); }));
                      });
                  }
                  return data;
              };

              try {
                  let data = await tryFetch(buildParams(false));
                  if (!data?.data?.length) {
                      data = await tryFetch(buildParams(true));
                  }
                                    if (data?.data?.length) {
                      const idx = Math.floor(Math.random() * data.data.length);
                      const pick = data.data[idx];
                                              if (prefetchOnly) {
                                                  // Only stage next wallpaper using proxy-aware resolution
                                                  resolveDisplayUrl(pick.path, (fetchConfig?.imageProxyMode) || 'auto')
                                                        .then((resolved) => preloadImage(resolved).then(() => setNextWallpaper({ id: pick.id, path: pick.path, displayUrl: resolved, loaded: true })))
                                                        .catch(() => setNextWallpaper(null));
                                            } else {
                          // Apply now and stage another if possible
                          setConfig(prev => ({ ...prev, wallhavenPath: pick.path, wallhavenId: pick.id }));
                          const nextIdx = (idx + 1) % data.data.length;
                          if (data.data.length > 1) {
                              const candidate = data.data[nextIdx];
                                                              resolveDisplayUrl(candidate.path, (fetchConfig?.imageProxyMode) || 'auto')
                                                                .then((resolved) => preloadImage(resolved).then(() => setNextWallpaper({ id: candidate.id, path: candidate.path, displayUrl: resolved, loaded: true })))
                                                                .catch(() => setNextWallpaper(null));
                          } else {
                              setNextWallpaper(null);
                          }
                      }
                  } else {
                      showNotification('No images found for the selected criteria.', true);
                  }
              } catch (err) {
                  console.warn('Wallhaven fetch failed:', err);
                  showNotification('Fetch failed after trying all proxies.', true);
              } finally {
                  setIsRefreshing(false);
              }
          }, []);

          useEffect(() => {
              const savedConfig = localStorage.getItem('startpageConfig');
              const initialConfig = {
                  bgMode: 'url',
                  bgUrl: 'background.gif',
                  wallhavenPath: '',
                  wallhavenId: null,
                  wallhavenThumb: '',
                  wallhavenTags: '',
                  wallhavenSorting: 'toplist',
                  wallhavenCategories: [true, true, true],
                  wallhavenPurity: [true, false, false],
                  wallhavenApiKey: '',
                  wallhavenMatchResolution: true,
                  imageProxyMode: 'auto',
                  dateMode: 'full',
                  shortcuts: [
                      { name: 'Reddit', url: 'https://reddit.com' },
                      { name: 'YouTube', url: 'https://youtube.com' },
                      { name: 'GitHub', url: 'https://github.com' },
                  ]
              };
              if (savedConfig) {
                  const parsedConfig = JSON.parse(savedConfig);
                  setConfig({...initialConfig, ...parsedConfig});
              } else {
                  setConfig(initialConfig);
              }
          }, []);

          useEffect(() => {
              if(config) {
                localStorage.setItem('startpageConfig', JSON.stringify(config));
              }
          }, [config]);

          const showNotification = useCallback((message, isError = false) => {
              setNotification({ show: true, message, isError });
              if (notifTimeoutRef.current) clearTimeout(notifTimeoutRef.current);
              notifTimeoutRef.current = setTimeout(() => setNotification({ show: false, message: '', isError: false }), 4000);
          }, []);

          const handleRefresh = useCallback(() => {
              if (isRefreshing) return;
          if (config.bgMode === 'wallhaven') {
                  if (nextWallpaper?.loaded) {
                      // Swap instantly to prefetched wallpaper
                      setConfig(prev => ({ ...prev, wallhavenPath: nextWallpaper.path, wallhavenId: nextWallpaper.id }));
                      setNextWallpaper(null);
                      // Kick off fetching another next in background
              fetchWallhavenWallpaper(config, true);
                  } else {
              fetchWallhavenWallpaper(config, false);
                  }
              } else if (config.bgMode === 'url' && config.bgUrl) {
                  const currentUrl = config.bgUrl;
                  setConfig(c => ({...c, bgUrl: ''}));
                  setTimeout(() => setConfig(c => ({...c, bgUrl: currentUrl})), 10);
              }
          }, [config, isRefreshing, fetchWallhavenWallpaper, nextWallpaper]);
          
          useEffect(() => {
              const mainBg = document.getElementById('background-container');
              if (!mainBg) return;

              const displayUrl = config?.bgMode === 'url' ? config.bgUrl : config?.wallhavenPath;
              if (displayUrl) {
                  // Resolve through proxy if needed, then apply; use a CORS-capable URL for analysis
                  resolveDisplayUrl(displayUrl, config?.imageProxyMode || 'auto')
                    .then((resolvedUrl) => {
                        mainBg.style.backgroundImage = `url('${resolvedUrl}')`;
                        const analysisUrl = getAnalysisUrl(displayUrl, resolvedUrl);
                        lastImageUrlRef.current = analysisUrl;
                        const key = getWallpaperKey();
                        const saved = key ? overlayPositions[key] : null;
                        if (saved && contentRef.current) {
                            const rect = contentRef.current.getBoundingClientRect();
                            const clamped = clampPos(saved.x, saved.y, rect.width, rect.height);
                            setOverlayPos(clamped);
                            overlayPosRef.current = clamped;
                            manualOverrideRef.current = true;
                        } else {
                            manualOverrideRef.current = false;
                            Promise.resolve(analyzeAndPosition(analysisUrl)).catch(() => { setOverlayPos(null); overlayPosRef.current = null; });
                        }
                    })
                    .catch(() => {
                        mainBg.style.backgroundImage = `url('background.gif')`;
                        lastImageUrlRef.current = null;
                        manualOverrideRef.current = false;
                        setOverlayPos(null);
                        overlayPosRef.current = null;
                    });
              } else {
                  mainBg.style.backgroundImage = `url('background.gif')`;
                  lastImageUrlRef.current = null;
                  setOverlayPos(null); // center overlay when no custom wallpaper
                  overlayPosRef.current = null;
              }
          }, [config?.bgMode, config?.bgUrl, config?.wallhavenPath, overlayPositions, getWallpaperKey]);

          // Re-analyze on resize
          useEffect(() => {
              const onResize = () => {
                  const url = lastImageUrlRef.current;
                  if (url && !manualOverrideRef.current) analyzeAndPosition(url);
              };
              window.addEventListener('resize', onResize);
              return () => window.removeEventListener('resize', onResize);
          }, []);

          // Drag to move overlay
          const clampPos = (x, y, w, h) => {
              const vw = window.innerWidth || document.documentElement.clientWidth;
              const vh = window.innerHeight || document.documentElement.clientHeight;
              const clampedX = Math.max(8, Math.min(x, vw - w - 8));
              const clampedY = Math.max(8, Math.min(y, vh - h - 8));
              return { x: clampedX, y: clampedY };
          };

          const onOverlayPointerDown = (e) => {
              if (e.button !== 0) return; // left click only
              // Ignore drags starting on links or buttons inside shortcuts
              const target = e.target;
              if (target.closest && (target.closest('a') || target.closest('button'))) return;
              const el = contentRef.current;
              if (!el) return;
              e.preventDefault();
              manualOverrideRef.current = true; // immediately prefer manual placement during drag
              analyzeRunIdRef.current++; // cancel any in-flight analysis to avoid snapping back
              const rect = el.getBoundingClientRect();
              overlaySizeRef.current = { w: rect.width, h: rect.height };
              // If not already absolutely positioned, initialize from current rect
              if (!overlayPos) {
                  const init = clampPos(rect.left, rect.top, rect.width, rect.height);
                  setOverlayPos(init);
                  overlayPosRef.current = init;
                  overlayStartRef.current = init;
              } else {
                  overlayStartRef.current = { ...overlayPos };
              }
              isDraggingRef.current = true;
              dragStartRef.current = { x: e.clientX, y: e.clientY };
              window.addEventListener('pointermove', onOverlayPointerMove);
              window.addEventListener('pointerup', onOverlayPointerUp, { once: true });
          };

          const onOverlayPointerMove = (e) => {
              if (!isDraggingRef.current) return;
              const dx = e.clientX - dragStartRef.current.x;
              const dy = e.clientY - dragStartRef.current.y;
              const { w, h } = overlaySizeRef.current;
              const next = clampPos(overlayStartRef.current.x + dx, overlayStartRef.current.y + dy, w, h);
              setOverlayPos(next);
              overlayPosRef.current = next;
          };

          const onOverlayPointerUp = () => {
              isDraggingRef.current = false;
              manualOverrideRef.current = true; // stick until wallpaper changes
              window.removeEventListener('pointermove', onOverlayPointerMove);
              const key = getWallpaperKey();
              const finalPos = overlayPosRef.current || overlayPos;
              if (key && finalPos) {
                  saveOverlayPosition(key, finalPos);
              }
          };

          if (!config) {
            return <div className="bg-gray-900 min-h-screen"></div>;
          }

          return (
              <React.Fragment>
                  <div id="background-container" className="fixed inset-0 bg-cover bg-center transition-all duration-500 z-0"></div>
                  <div id="notification" role="status" aria-live="polite" aria-atomic="true" className={`fixed top-5 left-1/2 -translate-x-1/2 py-2 px-5 rounded-lg shadow-lg opacity-0 -translate-y-10 z-50 transition-all ${notification.show ? 'opacity-100 translate-y-0' : ''} ${notification.isError ? 'bg-red-500' : 'bg-green-500'}`}>
                      <p>{notification.message}</p>
                  </div>
                  <main id="main-content" className="relative z-10 flex flex-col items-center justify-center h-screen box-border p-4 sm:p-6 overflow-hidden">
                      <div ref={contentRef}
                           onPointerDown={onOverlayPointerDown}
                           className={`flex flex-col items-center gap-6 cursor-move ${overlayPos ? '' : ''}`}
                           style={overlayPos ? { position: 'absolute', left: overlayPos.x + 'px', top: overlayPos.y + 'px', userSelect: isDraggingRef.current ? 'none' : undefined } : { userSelect: isDraggingRef.current ? 'none' : undefined }}>
                          <Clock dateMode={config.dateMode} />
                          <ShortcutsGrid shortcuts={config.shortcuts} />
                      </div>
                  </main>
                  {config.bgMode === 'wallhaven' && config.wallhavenId && (
                       <a href={`https://wallhaven.cc/w/${config.wallhavenId}`} target="_blank" className="fixed bottom-5 left-1/2 -translate-x-1/2 p-2 px-4 rounded-full text-white text-sm transition-opacity hover:opacity-100 opacity-70 z-20 acrylic-box">
                          Wallpaper Info
                       </a>
                  )}
                  <button onClick={handleRefresh} disabled={isRefreshing} className="fixed bottom-5 left-5 p-3 rounded-full text-white transition-colors focus:outline-none focus:ring-2 focus:ring-white z-20 disabled:opacity-50 acrylic-box">
                      {isRefreshing ? <Spinner /> : <Icon path="M4 4v5h5M20 20v-5h-5M4 20h5v-5M20 4h-5v5" />}
                  </button>
                  <button onClick={() => setIsSettingsOpen(true)} className="fixed bottom-5 right-5 p-3 rounded-full text-white transition-colors focus:outline-none focus:ring-2 focus:ring-white z-20 acrylic-box">
                      <Icon path="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065zM15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                  </button>
                  <SettingsPanel config={config} setConfig={setConfig} isOpen={isSettingsOpen} onClose={() => setIsSettingsOpen(false)} showNotification={showNotification} fetchWallhavenWallpaper={fetchWallhavenWallpaper}/>
              </React.Fragment>
          );
      }

            const root = ReactDOM.createRoot(document.getElementById('root'));
            root.render(<App />);

            // Register Service Worker (optional)
            if ('serviceWorker' in navigator) {
                window.addEventListener('load', () => {
                    navigator.serviceWorker.register('sw.js').catch(err => console.warn('SW registration failed', err));
                });
            }
    </script>
  </body>
</html>
