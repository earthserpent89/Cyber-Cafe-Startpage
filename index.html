<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Cyber Cafe Startpage</title>
    <meta name="theme-color" content="#111827" />
    <link rel="manifest" href="manifest.json" />
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <!-- React Libraries -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <!-- Babel Compiler -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
    html, body { height: 100%; overflow: hidden; overscroll-behavior: none; }
    html { overflow-x: clip; }
    *, *::before, *::after { box-sizing: border-box; }
      body {
        font-family: 'Inter', sans-serif;
        background-color: #111827; /* bg-gray-900 */
        color: white;
        min-height: 100vh;
                margin: 0;
      }
    #root, #main-content { width: 100vw; height: 100vh; overflow: hidden; }
            @media (prefers-reduced-motion: reduce) {
                * { transition: none !important; animation: none !important; }
            }
      .acrylic-box {
        background-color: rgba(0, 0, 0, 0.25);
        backdrop-filter: blur(10px);
        -webkit-backdrop-filter: blur(10px);
        border: 1px solid rgba(255, 255, 255, 0.1);
        border-radius: 0.75rem;
      }
      .filter-btn {
        flex-grow: 1;
        padding: 0.5rem 0;
        border: 1px solid #4b5563;
        background-color: rgba(75, 85, 99, 0.5);
        color: #d1d5db;
        font-weight: 500;
        transition: all 0.2s;
        cursor: pointer;
      }
      .filter-btn:not(:first-child) {
        border-left-width: 0;
      }
      .filter-btn.general-active, .filter-btn.anime-active, .filter-btn.people-active {
        background-color: #4338ca;
        border-color: #4f46e5;
        color: white;
      }
      .filter-btn.sfw-active { background-color: #166534; border-color: #15803d; color: white; }
      .filter-btn.sketchy-active { background-color: #854d0e; border-color: #a16207; color: white; }
      .filter-btn.nsfw-active { background-color: #991b1b; border-color: #b91c1c; color: white; }
      .form-checkbox {
        appearance: none;
        -webkit-appearance: none;
        height: 1.25rem;
        width: 1.25rem;
        border: 1px solid #4b5563;
        border-radius: 0.25rem;
        background-color: rgba(31, 41, 55, 0.5);
        cursor: pointer;
        display: inline-block;
        position: relative;
      }
      .form-checkbox:checked {
        background-color: #4f46e5;
        border-color: #4f46e5;
      }
      .form-checkbox:checked::after {
        content: 'âœ”';
        font-size: 0.8rem;
        color: white;
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
      }
      #background-container {
        transition: background-image 0.5s ease-in-out;
      }
    </style>
  </head>
  <body>
    <div id="root"></div>

        <script type="text/babel">
            const { useState, useEffect, useCallback, useMemo, useRef } = React;

      // --- Helper Components ---
      const Icon = ({ path, className = "h-6 w-6" }) => (
          <svg xmlns="http://www.w3.org/2000/svg" className={className} fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d={path} />
          </svg>
      );
    const Spinner = () => <div className="animate-spin rounded-full h-6 w-6 border-b-2 border-white"></div>;

      // --- Main App Components ---
      const Clock = ({ dateMode }) => {
          const [time, setTime] = useState(new Date());
          useEffect(() => {
              const timerId = setInterval(() => setTime(new Date()), 1000);
              return () => clearInterval(timerId);
          }, []);
          const formattedDate = useMemo(() => {
              const now = new Date();
              switch (dateMode) {
                  case 'full': return now.toLocaleDateString([], { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });
                  case 'day': return now.toLocaleDateString([], { weekday: 'long' });
                  case 'none': return '';
                  default: return '';
              }
          }, [dateMode, time]);
          return (
              <div className="text-center mb-8 p-4 acrylic-box">
                  <h1 id="time" className="text-6xl md:text-8xl font-bold tracking-tight">{time.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: true })}</h1>
                  <p id="date" className="text-lg md:text-2xl opacity-80">{formattedDate}</p>
              </div>
          );
      };

      const ShortcutsGrid = ({ shortcuts }) => (
          <div id="shortcuts-flex-container" className="inline-flex flex-wrap justify-center gap-4 p-4 acrylic-box max-w-4xl">
              {shortcuts.map((shortcut, index) => (
                  <a key={index} href={shortcut.url} target="_blank" rel="noopener noreferrer" className="w-32 h-16 bg-black/20 p-2 rounded-lg text-center hover:bg-black/40 transition-colors flex items-center justify-center">
                      <span className="font-medium truncate">{shortcut.name}</span>
                  </a>
              ))}
          </div>
      );

      const SettingsPanel = ({ config, setConfig, isOpen, onClose, showNotification, fetchWallhavenWallpaper }) => {
          const [activeTab, setActiveTab] = useState('display');
          const [localConfig, setLocalConfig] = useState(config);
          useEffect(() => { if (isOpen) { setLocalConfig(config); } }, [config, isOpen]);
          // Close on Escape
          useEffect(() => {
              if (!isOpen) return;
              const onKey = (e) => { if (e.key === 'Escape') onClose(); };
              window.addEventListener('keydown', onKey);
              return () => window.removeEventListener('keydown', onKey);
          }, [isOpen, onClose]);
          
          const handleSave = () => {
              const finalConfig = { ...localConfig };
              const oldConfig = { ...config };
              
              // Sanitize bgUrl and decide mode
              const rawUrl = (localConfig.bgUrl || '').trim();
              if (rawUrl) {
                  try {
                      const u = new URL(rawUrl, window.location.href);
                      if (u.protocol === 'http:' || u.protocol === 'https:') {
                          finalConfig.bgUrl = u.href;
                          finalConfig.bgMode = 'url';
                      } else {
                          showNotification('Unsupported image URL protocol. Using Wallhaven.', true);
                          finalConfig.bgUrl = '';
                          finalConfig.bgMode = 'wallhaven';
                      }
                  } catch {
                      showNotification('Invalid image URL. Using Wallhaven.', true);
                      finalConfig.bgUrl = '';
                      finalConfig.bgMode = 'wallhaven';
                  }
              } else {
                  finalConfig.bgMode = 'wallhaven';
              }
              
              setConfig(finalConfig);
              onClose();
              showNotification("Settings saved.", false);

              if (finalConfig.bgMode === 'wallhaven' && JSON.stringify(oldConfig) !== JSON.stringify(finalConfig)) {
                  fetchWallhavenWallpaper(finalConfig);
              }
          };

          const handleConfigChange = (field, value) => setLocalConfig(prev => ({ ...prev, [field]: value }));
          const handleDateModeChange = (e) => {
              const newDateMode = e.target.value;
              setLocalConfig(prev => ({ ...prev, dateMode: newDateMode }));
              setConfig(prev => ({ ...prev, dateMode: newDateMode }));
          };
          const handleCategoryChange = (index) => {
              const newCategories = [...localConfig.wallhavenCategories];
              newCategories[index] = !newCategories[index];
              handleConfigChange('wallhavenCategories', newCategories);
          };
          const handlePurityChange = (index) => {
              const newPurity = [...localConfig.wallhavenPurity];
              newPurity[index] = !newPurity[index];
              handleConfigChange('wallhavenPurity', newPurity);
          };
          const isWallhavenDisabled = localConfig.bgUrl.trim() !== '';
          const isNsfwDisabled = isWallhavenDisabled || !localConfig.wallhavenApiKey;
          return (
              <div role="dialog" aria-modal="true" aria-label="Settings" className={`fixed top-0 right-0 h-full w-full max-w-md bg-gray-800/70 backdrop-blur-md shadow-2xl flex flex-col transform transition-transform z-30 ${isOpen ? 'translate-x-0' : 'translate-x-full'}`}>
                  <div className="flex justify-between items-center p-6 border-b border-gray-700 flex-shrink-0">
                      <h2 className="text-2xl font-bold">Settings</h2>
                      <button onClick={onClose} className="p-2 rounded-full hover:bg-white/10 transition-colors"><Icon path="M6 18L18 6M6 6l12 12" /></button>
                  </div>
                  <div className="flex border-b border-gray-600 flex-shrink-0">
                      <button onClick={() => setActiveTab('display')} className={`py-2 px-4 w-1/2 ${activeTab === 'display' ? 'border-b-2 border-indigo-500 text-white' : 'text-gray-400'}`}>Display & Wallpaper</button>
                      <button onClick={() => setActiveTab('shortcuts')} className={`py-2 px-4 w-1/2 ${activeTab === 'shortcuts' ? 'border-b-2 border-indigo-500 text-white' : 'text-gray-400'}`}>Shortcuts</button>
                  </div>
                  <div className="flex-grow p-6 space-y-6 overflow-y-auto">
                      {activeTab === 'display' && (
                          <div className="space-y-6">
                              <section>
                                  <h3 className="text-lg font-semibold mb-4 text-indigo-400">General</h3>
                                  <div>
                                      <label htmlFor="date-display-mode" className="block text-sm font-medium mb-1">Date Format</label>
                                      <select value={localConfig.dateMode} onChange={handleDateModeChange} className="w-full bg-gray-900/50 border border-gray-700 rounded-md px-3 py-2 text-white focus:outline-none focus:ring-2 focus:ring-indigo-500">
                                          <option value="full">Full Date</option>
                                          <option value="day">Day of the Week Only</option>
                                          <option value="none">Hide Date</option>
                                      </select>
                                  </div>
                              </section>
                              <hr className="border-gray-700"/>
                              <section>
                                  <h3 className="text-lg font-semibold mb-4 text-indigo-400">Wallpaper</h3>
                                  <div className="space-y-2">
                                      <label htmlFor="wallpaper-url" className="block text-sm font-medium">Custom URL</label>
                                      <input id="wallpaper-url" type="text" value={localConfig.bgUrl} onChange={(e) => handleConfigChange('bgUrl', e.target.value)} placeholder="Enter an image URL to override Wallhaven" className="w-full bg-gray-900/50 border border-gray-700 rounded-md px-3 py-2 text-white focus:outline-none focus:ring-2 focus:ring-blue-500" />
                                  </div>
                                  <div className={`space-y-4 mt-4 transition-opacity ${isWallhavenDisabled ? 'opacity-50' : ''}`}>
                                      <p className="text-sm opacity-70">Or, configure Wallhaven (active when Custom URL is empty).</p>
                                      <div>
                                          <label className="block text-sm font-medium mb-2">Filters</label>
                                          <div className="grid grid-cols-3 gap-1">
                                              <button onClick={() => handleCategoryChange(0)} disabled={isWallhavenDisabled} className={`filter-btn rounded-l-md ${localConfig.wallhavenCategories[0] ? 'general-active' : ''}`}>General</button>
                                              <button onClick={() => handleCategoryChange(1)} disabled={isWallhavenDisabled} className={`filter-btn ${localConfig.wallhavenCategories[1] ? 'anime-active' : ''}`}>Anime</button>
                                              <button onClick={() => handleCategoryChange(2)} disabled={isWallhavenDisabled} className={`filter-btn rounded-r-md ${localConfig.wallhavenCategories[2] ? 'people-active' : ''}`}>People</button>
                                              <button onClick={() => handlePurityChange(0)} disabled={isWallhavenDisabled} className={`filter-btn rounded-l-md ${localConfig.wallhavenPurity[0] ? 'sfw-active' : ''}`}>SFW</button>
                                              <button onClick={() => handlePurityChange(1)} disabled={isWallhavenDisabled} className={`filter-btn ${localConfig.wallhavenPurity[1] ? 'sketchy-active' : ''}`}>Sketchy</button>
                                              <button onClick={() => handlePurityChange(2)} disabled={isNsfwDisabled} className={`filter-btn rounded-r-md ${localConfig.wallhavenPurity[2] ? 'nsfw-active' : ''} ${isNsfwDisabled ? 'opacity-50 cursor-not-allowed' : ''}`}>NSFW</button>
                                          </div>
                                      </div>
                                      <div>
                                          <label htmlFor="wallhaven-tags" className="block text-sm font-medium mb-1">Tags</label>
                                          <input id="wallhaven-tags" type="text" value={localConfig.wallhavenTags} onChange={e => handleConfigChange('wallhavenTags', e.target.value)} placeholder="digital art, landscape" disabled={isWallhavenDisabled} className="w-full bg-gray-900/50 border border-gray-700 rounded-md px-3 py-2 text-white focus:outline-none focus:ring-2 focus:ring-indigo-500 disabled:cursor-not-allowed" />
                                      </div>
                                      <div>
                                          <label htmlFor="wallhaven-sorting" className="block text-sm font-medium mb-1">Sort By</label>
                                          <select id="wallhaven-sorting" value={localConfig.wallhavenSorting} onChange={e => handleConfigChange('wallhavenSorting', e.target.value)} disabled={isWallhavenDisabled} className="w-full bg-gray-900/50 border border-gray-700 rounded-md px-3 py-2 text-white focus:outline-none focus:ring-2 focus:ring-indigo-500 disabled:cursor-not-allowed">
                                              <option value="random">Random</option>
                                              <option value="toplist">Toplist</option>
                                              <option value="hot">Hot</option>
                                              <option value="date_added">Newest</option>
                                              <option value="views">Views</option>
                                              <option value="favorites">Favorites</option>
                                          </select>
                                      </div>
                                      <div>
                                          <label className={`flex items-center space-x-2 ${isWallhavenDisabled ? '' : 'cursor-pointer'}`}>
                                              <input type="checkbox" checked={localConfig.wallhavenMatchResolution} onChange={e => handleConfigChange('wallhavenMatchResolution', e.target.checked)} disabled={isWallhavenDisabled} className="form-checkbox" />
                                              <span>Match Screen Resolution</span>
                                          </label>
                                      </div>
                                      <div>
                                          <label htmlFor="wallhaven-apikey" className="block text-sm font-medium mb-1">API Key</label>
                                          <input id="wallhaven-apikey" type="password" value={localConfig.wallhavenApiKey} onChange={e => handleConfigChange('wallhavenApiKey', e.target.value)} disabled={isWallhavenDisabled} placeholder="Optional, for full access" className="w-full bg-gray-900/50 border border-gray-700 rounded-md px-3 py-2 text-white focus:outline-none focus:ring-2 focus:ring-indigo-500 disabled:cursor-not-allowed" />
                                          <p className="text-xs text-gray-400 mt-1">An API key is required for NSFW content. Get yours from your <a href="https://wallhaven.cc/settings/account" target="_blank" rel="noopener noreferrer" className="text-indigo-400 hover:underline">account settings</a>.</p>
                                      </div>
                                  </div>
                              </section>
                          </div>
                      )}
                      {activeTab === 'shortcuts' && (
                           <section>
                              <h3 className="text-lg font-semibold mb-4 text-indigo-400">Shortcuts</h3>
                              <div className="space-y-3">
                                  {localConfig.shortcuts.map((shortcut, index) => (
                                      <div key={index} className="flex gap-2 items-center">
                                          <input type="text" value={shortcut.name} onChange={e => {
                                              const newShortcuts = [...localConfig.shortcuts];
                                              newShortcuts[index].name = e.target.value;
                                              handleConfigChange('shortcuts', newShortcuts);
                                          }} className="w-1/3 bg-gray-900/50 border border-gray-700 rounded-md px-3 py-2 text-white focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="Name" />
                                          <input type="text" value={shortcut.url} onChange={e => {
                                              const newShortcuts = [...localConfig.shortcuts];
                                              newShortcuts[index].url = e.target.value;
                                              handleConfigChange('shortcuts', newShortcuts);
                                          }} className="w-2/3 bg-gray-900/50 border border-gray-700 rounded-md px-3 py-2 text-white focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="URL" />
                                          <button onClick={() => {
                                              const newShortcuts = localConfig.shortcuts.filter((_, i) => i !== index);
                                              handleConfigChange('shortcuts', newShortcuts);
                                          }} className="text-red-500 hover:text-red-400 p-2 rounded-full hover:bg-white/10 transition-colors">
                                              <Icon path="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" className="h-5 w-5" />
                                          </button>
                                      </div>
                                  ))}
                              </div>
                              <button onClick={() => handleConfigChange('shortcuts', [...localConfig.shortcuts, { name: 'New Link', url: 'https://' }])} className="mt-4 w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-md transition-colors">Add Shortcut</button>
                          </section>
                      )}
                  </div>
                  <div className="p-6 border-t border-gray-700 flex-shrink-0">
                      <button onClick={handleSave} className="w-full bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-md transition-colors">Save Changes</button>
                  </div>
              </div>
          );
      };

      function App() {
          const [config, setConfig] = useState(null);
          const [isSettingsOpen, setIsSettingsOpen] = useState(false);
          const [notification, setNotification] = useState({ show: false, message: '', isError: false });
          const [isRefreshing, setIsRefreshing] = useState(false);
          const notifTimeoutRef = useRef(null);
          const [nextWallpaper, setNextWallpaper] = useState(null); // { id, path, loaded }
          const contentRef = useRef(null);
          const [overlayPos, setOverlayPos] = useState(null); // { x, y } in px; null = centered
          const lastImageUrlRef = useRef(null);

          const getAtLeastResolution = () => `${window.screen.width}x${window.screen.height}`;

          // Small helper: fetch with timeout
          const fetchWithTimeout = (url, { timeout = 8000 } = {}) => {
              const ctrl = new AbortController();
              const id = setTimeout(() => ctrl.abort('timeout'), timeout);
              return fetch(url, { signal: ctrl.signal }).finally(() => clearTimeout(id));
          };

          const preloadImage = (url) => new Promise((resolve, reject) => {
              const img = new Image();
              // Do not set crossOrigin here; we only need the browser cache and CSS bg to succeed
              img.onload = () => resolve(url);
              img.onerror = reject;
              img.src = url;
          });

          const loadImage = (url) => new Promise((resolve, reject) => {
              const img = new Image();
              try { img.crossOrigin = 'anonymous'; } catch {}
              img.onload = () => resolve(img);
              img.onerror = reject;
              img.src = url;
          });

          const analyzeAndPosition = async (imgUrl) => {
              try {
                  const contentEl = contentRef.current;
                  if (!contentEl) return setOverlayPos(null);
                  // Measure overlay size
                  const rect = contentEl.getBoundingClientRect();
                  const vw = window.innerWidth || document.documentElement.clientWidth;
                  const vh = window.innerHeight || document.documentElement.clientHeight;
                  if (!rect.width || !rect.height || !vw || !vh) return setOverlayPos(null);

                  const img = await loadImage(imgUrl);
                  // Build a canvas that matches viewport aspect for consistent mapping
                  const cw = 160; // keep small for speed
                  const ch = Math.max(90, Math.round(cw * vh / Math.max(1, vw)));
                  const canvas = document.createElement('canvas');
                  canvas.width = cw; canvas.height = ch;
                  const ctx = canvas.getContext('2d');
                  ctx.drawImage(img, 0, 0, cw, ch);
                  const imageData = ctx.getImageData(0, 0, cw, ch);
                  const data = imageData.data;
                  // Luminance array
                  const lum = new Float32Array(cw * ch);
                  for (let y = 0, i = 0, p = 0; y < ch; y++) {
                      for (let x = 0; x < cw; x++, i++, p += 4) {
                          const r = data[p], g = data[p+1], b = data[p+2];
                          lum[i] = 0.299*r + 0.587*g + 0.114*b;
                      }
                  }
                  // Simple gradient energy: right and down diffs
                  const energy = new Float32Array(cw * ch);
                  let total = 0;
                  for (let y = 0; y < ch; y++) {
                      for (let x = 0; x < cw; x++) {
                          const i = y*cw + x;
                          const right = x+1 < cw ? lum[y*cw + (x+1)] : lum[i];
                          const down  = y+1 < ch ? lum[(y+1)*cw + x] : lum[i];
                          const e = Math.abs(lum[i] - right) + Math.abs(lum[i] - down);
                          energy[i] = e; total += e;
                      }
                  }
                  const avgEnergy = total / (cw * ch);
                  // Integral image for fast area sums
                  const integral = new Float32Array((cw+1) * (ch+1));
                  for (let y = 1; y <= ch; y++) {
                      let rowSum = 0;
                      for (let x = 1; x <= cw; x++) {
                          rowSum += energy[(y-1)*cw + (x-1)];
                          integral[y*(cw+1) + x] = integral[(y-1)*(cw+1) + x] + rowSum;
                      }
                  }
                  const targetW = Math.max(8, Math.round(rect.width / vw * cw));
                  const targetH = Math.max(8, Math.round(rect.height / vh * ch));
                  const marginX = Math.round(0.02 * cw); // ~2% canvas margin
                  const marginY = Math.round(0.02 * ch);
                  let best = { score: Number.POSITIVE_INFINITY, x: Math.round((cw-targetW)/2), y: Math.round((ch-targetH)/2) };
                  const cx = cw/2, cy = ch/2;
                  // Iterate candidate positions
                  for (let y = marginY; y <= ch - targetH - marginY; y++) {
                      for (let x = marginX; x <= cw - targetW - marginX; x++) {
                          const x2 = x + targetW, y2 = y + targetH;
                          const sum = integral[y2*(cw+1) + x2] - integral[y*(cw+1) + x2] - integral[y2*(cw+1) + x] + integral[y*(cw+1) + x];
                          // Prefer minimal energy; mild bias away from center only if energies are close
                          const centerDist = Math.hypot((x + targetW/2) - cx, (y + targetH/2) - cy) / Math.hypot(cx, cy);
                          const score = sum + centerDist * 0.02 * avgEnergy * targetW * targetH;
                          if (score < best.score) best = { score, x, y };
                      }
                  }
                  const windowEnergyPerPixel = best.score / (targetW * targetH);
                  // If no clearly low-energy region, fall back to center
                  if (windowEnergyPerPixel > avgEnergy * 0.95) {
                      setOverlayPos(null);
                      return;
                  }
                  const px = Math.round(best.x / cw * vw);
                  const py = Math.round(best.y / ch * vh);
                  const clampedX = Math.max(8, Math.min(px, vw - rect.width - 8));
                  const clampedY = Math.max(8, Math.min(py, vh - rect.height - 8));
                  setOverlayPos({ x: clampedX, y: clampedY });
              } catch (err) {
                  // Likely CORS-tainted canvas or other issue; fall back to center
                  setOverlayPos(null);
              }
          };

          const fetchWallhavenWallpaper = useCallback(async (fetchConfig, prefetchOnly = false) => {
              setIsRefreshing(true);
              const proxies = ['https://corsproxy.io/?', 'https://api.allorigins.win/raw?url='];
              const { wallhavenTags, wallhavenSorting, wallhavenCategories, wallhavenPurity, wallhavenApiKey, wallhavenMatchResolution } = fetchConfig;

              const buildParams = (relax = false) => {
                  const params = new URLSearchParams();
                  const tags = (wallhavenTags || '').trim();
                  const cats = (wallhavenCategories || [true, true, true]).map(c => c ? '1' : '0').join('');
                  const purityFlags = [...(wallhavenPurity || [true, false, false])];
                  const purity = purityFlags.map(p => p ? '1' : '0').join('');

                  if (!relax && tags) params.append('q', tags);
                  params.append('sorting', wallhavenSorting || 'toplist');
                  params.append('categories', cats);
                  params.append('purity', purity);
                  if (!relax && wallhavenMatchResolution) {
                      params.append('atleast', getAtLeastResolution());
                  }
                  if ((wallhavenSorting || 'toplist') === 'random') {
                      const seed = new Date().toISOString().slice(0, 10); // daily seed
                      params.append('seed', seed);
                  }
                  if (wallhavenApiKey) params.append('apikey', wallhavenApiKey);
                  return params;
              };

              const tryFetch = async (params) => {
                  const apiUrl = `https://wallhaven.cc/api/v1/search?${params.toString()}`;
                  const attempts = proxies.map(p => (
                      fetchWithTimeout(p + encodeURIComponent(apiUrl), { timeout: 9000 })
                        .then(r => { if (!r.ok) throw new Error(`HTTP ${r.status}`); return r.json(); })
                  ));
                  let data;
                  if (Promise.any) {
                      data = await Promise.any(attempts);
                  } else {
                      data = await new Promise((resolve, reject) => {
                          let rejections = 0;
                          attempts.forEach(p => p.then(resolve).catch(() => { rejections++; if (rejections === attempts.length) reject(new Error('All proxies failed')); }));
                      });
                  }
                  return data;
              };

              try {
                  let data = await tryFetch(buildParams(false));
                  if (!data?.data?.length) {
                      data = await tryFetch(buildParams(true));
                  }
                  if (data?.data?.length) {
                      const idx = Math.floor(Math.random() * data.data.length);
                      const pick = data.data[idx];
                      if (prefetchOnly) {
                          // Only stage next wallpaper
                          preloadImage(pick.path).then(() => setNextWallpaper({ id: pick.id, path: pick.path, loaded: true })).catch(() => setNextWallpaper(null));
                      } else {
                          // Apply now and stage another if possible
                          setConfig(prev => ({ ...prev, wallhavenPath: pick.path, wallhavenId: pick.id }));
                          const nextIdx = (idx + 1) % data.data.length;
                          if (data.data.length > 1) {
                              const candidate = data.data[nextIdx];
                              preloadImage(candidate.path).then(() => setNextWallpaper({ id: candidate.id, path: candidate.path, loaded: true })).catch(() => setNextWallpaper(null));
                          } else {
                              setNextWallpaper(null);
                          }
                      }
                  } else {
                      showNotification('No images found for the selected criteria.', true);
                  }
              } catch (err) {
                  console.warn('Wallhaven fetch failed:', err);
                  showNotification('Fetch failed after trying all proxies.', true);
              } finally {
                  setIsRefreshing(false);
              }
          }, []);

          useEffect(() => {
              const savedConfig = localStorage.getItem('startpageConfig');
              const initialConfig = {
                  bgMode: 'url',
                  bgUrl: 'background.gif',
                  wallhavenPath: '',
                  wallhavenId: null,
                  wallhavenThumb: '',
                  wallhavenTags: '',
                  wallhavenSorting: 'toplist',
                  wallhavenCategories: [true, true, true],
                  wallhavenPurity: [true, false, false],
                  wallhavenApiKey: '',
                  wallhavenMatchResolution: true,
                  dateMode: 'full',
                  shortcuts: [
                      { name: 'Reddit', url: 'https://reddit.com' },
                      { name: 'YouTube', url: 'https://youtube.com' },
                      { name: 'GitHub', url: 'https://github.com' },
                  ]
              };
              if (savedConfig) {
                  const parsedConfig = JSON.parse(savedConfig);
                  setConfig({...initialConfig, ...parsedConfig});
              } else {
                  setConfig(initialConfig);
              }
          }, []);

          useEffect(() => {
              if(config) {
                localStorage.setItem('startpageConfig', JSON.stringify(config));
              }
          }, [config]);

          const showNotification = useCallback((message, isError = false) => {
              setNotification({ show: true, message, isError });
              if (notifTimeoutRef.current) clearTimeout(notifTimeoutRef.current);
              notifTimeoutRef.current = setTimeout(() => setNotification({ show: false, message: '', isError: false }), 4000);
          }, []);

          const handleRefresh = useCallback(() => {
              if (isRefreshing) return;
          if (config.bgMode === 'wallhaven') {
                  if (nextWallpaper?.loaded) {
                      // Swap instantly to prefetched wallpaper
                      setConfig(prev => ({ ...prev, wallhavenPath: nextWallpaper.path, wallhavenId: nextWallpaper.id }));
                      setNextWallpaper(null);
                      // Kick off fetching another next in background
              fetchWallhavenWallpaper(config, true);
                  } else {
              fetchWallhavenWallpaper(config, false);
                  }
              } else if (config.bgMode === 'url' && config.bgUrl) {
                  const currentUrl = config.bgUrl;
                  setConfig(c => ({...c, bgUrl: ''}));
                  setTimeout(() => setConfig(c => ({...c, bgUrl: currentUrl})), 10);
              }
          }, [config, isRefreshing, fetchWallhavenWallpaper, nextWallpaper]);
          
          useEffect(() => {
              const mainBg = document.getElementById('background-container');
              if (!mainBg) return;

              const displayUrl = config?.bgMode === 'url' ? config.bgUrl : config?.wallhavenPath;
              if (displayUrl) {
                  preloadImage(displayUrl)
                    .then(() => { 
                        mainBg.style.backgroundImage = `url('${displayUrl}')`; 
                        lastImageUrlRef.current = displayUrl;
                        analyzeAndPosition(displayUrl);
                    })
                    .catch(() => {
                        // Prefetch failed (likely CORS), but CSS background can still load; apply without analysis
                        mainBg.style.backgroundImage = `url('${displayUrl}')`;
                        lastImageUrlRef.current = displayUrl;
                        setOverlayPos(null);
                    });
              } else {
                  mainBg.style.backgroundImage = `url('background.gif')`;
                  lastImageUrlRef.current = null;
                  setOverlayPos(null); // center overlay when no custom wallpaper
              }
          }, [config?.bgMode, config?.bgUrl, config?.wallhavenPath]);

          // Re-analyze on resize
          useEffect(() => {
              const onResize = () => {
                  const url = lastImageUrlRef.current;
                  if (url) analyzeAndPosition(url);
              };
              window.addEventListener('resize', onResize);
              return () => window.removeEventListener('resize', onResize);
          }, []);

          if (!config) {
            return <div className="bg-gray-900 min-h-screen"></div>;
          }

          return (
              <React.Fragment>
                  <div id="background-container" className="fixed inset-0 bg-cover bg-center transition-all duration-500 z-0"></div>
                  <div id="notification" role="status" aria-live="polite" aria-atomic="true" className={`fixed top-5 left-1/2 -translate-x-1/2 py-2 px-5 rounded-lg shadow-lg opacity-0 -translate-y-10 z-50 transition-all ${notification.show ? 'opacity-100 translate-y-0' : ''} ${notification.isError ? 'bg-red-500' : 'bg-green-500'}`}>
                      <p>{notification.message}</p>
                  </div>
                  <main id="main-content" className="relative z-10 flex flex-col items-center justify-center h-screen box-border p-4 sm:p-6 overflow-hidden">
                      <div ref={contentRef} className={`flex flex-col items-center gap-6 ${overlayPos ? '' : ''}`} style={overlayPos ? { position: 'absolute', left: overlayPos.x + 'px', top: overlayPos.y + 'px' } : {}}>
                          <Clock dateMode={config.dateMode} />
                          <ShortcutsGrid shortcuts={config.shortcuts} />
                      </div>
                  </main>
                  {config.bgMode === 'wallhaven' && config.wallhavenId && (
                       <a href={`https://wallhaven.cc/w/${config.wallhavenId}`} target="_blank" className="fixed bottom-5 left-1/2 -translate-x-1/2 p-2 px-4 rounded-full text-white text-sm transition-opacity hover:opacity-100 opacity-70 z-20 acrylic-box">
                          Wallpaper Info
                       </a>
                  )}
                  <button onClick={handleRefresh} disabled={isRefreshing} className="fixed bottom-5 left-5 p-3 rounded-full text-white transition-colors focus:outline-none focus:ring-2 focus:ring-white z-20 disabled:opacity-50 acrylic-box">
                      {isRefreshing ? <Spinner /> : <Icon path="M4 4v5h5M20 20v-5h-5M4 20h5v-5M20 4h-5v5" />}
                  </button>
                  <button onClick={() => setIsSettingsOpen(true)} className="fixed bottom-5 right-5 p-3 rounded-full text-white transition-colors focus:outline-none focus:ring-2 focus:ring-white z-20 acrylic-box">
                      <Icon path="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065zM15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                  </button>
                  <SettingsPanel config={config} setConfig={setConfig} isOpen={isSettingsOpen} onClose={() => setIsSettingsOpen(false)} showNotification={showNotification} fetchWallhavenWallpaper={fetchWallhavenWallpaper}/>
              </React.Fragment>
          );
      }

            const root = ReactDOM.createRoot(document.getElementById('root'));
            root.render(<App />);

            // Register Service Worker (optional)
            if ('serviceWorker' in navigator) {
                window.addEventListener('load', () => {
                    navigator.serviceWorker.register('sw.js').catch(err => console.warn('SW registration failed', err));
                });
            }
    </script>
  </body>
</html>
